import {
  app,
  BrowserWindow,
  Menu,
  MenuItem,
  MenuItemConstructorOptions,
  ipcMain,
  IpcMainEvent,
  dialog,
  webContents,
} from 'electron';

import * as net from 'net';
import { SerialPort } from 'serialport';

import type { ConnectionState, RongbukDevice } from './types/devices';

import {
  UltrasonicDataParser,
  MetadataPacket,
  DataPacket,
  ScanData,
} from './parser';

import { error } from 'console';
import discoverDevices from './discover-devices';

import {
  createTestingWindow,
  openTestingWindow,
  addTestingMenuToMainWindow,
} from './testing';

const parser = new UltrasonicDataParser();

parser.onDataPacketReceived = () => console.log('data packet arrived');
parser.onMetadataReceived = () => console.log('meta packet received');
parser.onScanComplete = () => console.log('scan complete');
parser.onParseError = () => console.log('parser error');

// Send data through current connection
// function sendData(data: string | Buffer): boolean {
//   if (
//     !currentConnection ||
//     currentConnection.descriptor.status !== 'connected'
//   ) {
//     console.error('No active connection');
//     return false;
//   }

//   try {
//     if (currentConnection.streams.network) {
//       currentConnection.streams.network.write(data);
//       return true;
//     } else if (currentConnection.streams.serial) {
//       currentConnection.streams.serial.write(data);
//       return true;
//     }
//   } catch (error) {
//     console.error('Failed to send data:', error);
//     return false;
//   }

//   return false;
// }

// Handle incoming data (unified for both connection types)
function handleIncomingData(data: Buffer) {
  // Process the data regardless of source
  console.log('Processing data:', data.toString());

  // Send to main window if needed
  mainWindow?.webContents.send('device-data', data.toString());
}

// Disconnect current device
// function disconnectCurrentDevice(): void {
//   if (!currentConnection) return;

//   try {
//     if (currentConnection.streams.network) {
//       currentConnection.streams.network.destroy();
//     } else if (currentConnection.streams.serial) {
//       currentConnection.streams.serial.close();
//     }
//   } catch (error) {
//     console.error('Error during disconnect:', error);
//   }

//   currentConnection = null;
// }

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).

/**
 * @ignore
 */
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

let mainWindow: BrowserWindow | null = null;
let currentDevice: RongbukDevice | null = null;
let currentSocket: net.Socket | null = null;
let currentPort: SerialPort | null = null;

const handleConnectDevice = (device: RongbukDevice | null) => {
  if (device === null) return;

  if (currentDevice !== null && currentDevice.connectionState === 'CONNECTED') {
    mainWindow?.webContents.send('device-update', currentDevice);
    return;
  }

  if (typeof device.location == 'string') {
    // com port
    currentPort = new SerialPort({
      path: device.location,
      baudRate: 115200,
    });
    currentPort.on('open', () => {});
    currentPort.on('data', data => {});
    currentPort.on('close', () => {});
    currentPort.on('error', err => {}); // there is .isOpen to differentiate
  } else {
    currentDevice = device;
    currentDevice.connectionState = 'DISCONNECTED';

    let received: number = 0;
    let timer: NodeJS.Timeout | null = null;

    currentSocket = net.createConnection(7332, device.location[0]);

    currentSocket.on('connect', () => {
      console.log(`connected to ${device.location[0]}`);
      currentDevice.connectionState = 'CONNECTED';
      mainWindow?.webContents.send('device-update', currentDevice);

      parser.reset();
      // TODO: register disconnect function
    });

    currentSocket.on('data', data => {
      parser.processData(new Uint8Array(data));
      received += data.length;

      if (timer !== null) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => {
        console.log(`received ${received} bytes`);
        timer = null;
      }, 5000);
    });

    currentSocket.on('close', () => {
      console.log('tcp connection closed');
      currentDevice.connectionState = 'DISCONNECTED';
      currentSocket = null;
      mainWindow?.webContents.send('device-update', currentDevice);
    });

    currentSocket.on('error', err => {
      console.log('tcp connection error', err);
      if (currentDevice.connectionState === 'CONNECTED') {
        currentSocket.destroy(); // close will follow soon.
      } else {
        currentSocket = null;
        dialog.showErrorBox(
          'Error',
          `Failed to establish a connection to ${device.name} at ${device.location}`
        );
      }
    });
  }
};

const handleDisconnectDevice = (device: RongbukDevice): void => {
  if (device.name !== currentDevice.name) return;
  if (currentDevice.connectionState === 'DISCONNECTED') return;
  if (currentSocket === null) return;
  currentSocket.destroy();
};

const MENUID_SELECTDEVICE = 'SelectDevice';

const updateMenuSelectDevice = (enabled: boolean): void => {
  const menu = Menu.getApplicationMenu();
  if (menu) {
    const item = menu.getMenuItemById(MENUID_SELECTDEVICE);
    if (item) {
      item.enabled = enabled;
    }
  }
};

/**
 * create main window, with extra menucommand
 */
const createMainWindow = (): void => {
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  // mainWindow.webContents.openDevTools();

  // const menuTemplate: MenuItemConstructorOptions[] = [
  //   { role: 'fileMenu' },
  //   { role: 'editMenu' },
  //   { role: 'viewMenu' },
  //   {
  //     label: 'Test',
  //     submenu: [
  //       {
  //         label: 'foo',
  //         click: () => {
  //           dialog.showMessageBox(mainWindow, {
  //             message: 'You clicked foo',
  //             type: 'info',
  //           });
  //         },
  //       },
  //       {
  //         label: 'bar',
  //         click: () => {
  //           dialog.showMessageBox(mainWindow, {
  //             message: 'You clicked bar',
  //             type: 'info',
  //           });
  //         },
  //       },
  //     ],
  //   },
  //   { role: 'windowMenu' },
  // ];

  // const menu = Menu.buildFromTemplate(menuTemplate);
  // Menu.setApplicationMenu(menu);
  // addTestingMenuToMainWindow(mainWindow);

  ipcMain.on('user-refresh-devices', () => {
    discoverDevices(device => {
      if (currentDevice !== null) {
        if (currentDevice.name === device.name) {
          device.connectionState = currentDevice.connectionState;
        }
      }
      mainWindow?.webContents.send('device-update', device);
    });
  });

  ipcMain.on(
    'user-connect-device',
    (event: IpcMainEvent, device: RongbukDevice) => {
      console.log('user-connect-device:', device);
      handleConnectDevice(device);
    }
  );

  ipcMain.on(
    'user-disconnect-device',
    (event: IpcMainEvent, device: RongbukDevice) => {
      console.log('user-disconnect-device:', device);
      handleDisconnectDevice(device);
    }
  );

  // don't delete the following settings, though not used now.
  // these function handles Web Serial API permission check
  // and is hard to make it work.
  mainWindow.webContents.session.on(
    'select-serial-port',
    (event, portList, webContents, callback) => {
      console.log('Available ports:', portList);

      if (portList && portList.length > 0) {
        callback(portList[0].portId);
      } else {
        callback('');
      }
    }
  );

  mainWindow.webContents.session.setPermissionCheckHandler(
    (webContents, permission, requestingOrigin, details) => {
      return permission === 'serial';
    }
  );

  mainWindow.webContents.session.setDevicePermissionHandler(details => {
    return details.deviceType === 'serial';
  });
};

/**
 * The following two functions are dealing with
 * the difference among platforms. On Linux and Windows, 'ready' is used,
 * while on macOS, 'activate' is used.
 */
app.on('ready', createMainWindow);
app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createMainWindow();
  }
});

/**
 * exit
 */
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

const refreshDevices = (): void => {};
