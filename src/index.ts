import {
  app,
  BrowserWindow,
  Menu,
  MenuItem,
  ipcMain,
  IpcMainEvent,
  dialog,
} from 'electron';

import * as net from 'net';
import { SerialPort } from 'serialport';

import type { ConnectionState, RongbukDevice } from './types/devices';

import SelectDevice, { SelectDeviceCallback } from './select-device';

import {
  UltrasonicDataParser,
  MetadataPacket,
  DataPacket,
  ScanData,
} from './parser';

import { error } from 'console';

const parser = new UltrasonicDataParser();

parser.onDataPacketReceived = () => console.log('data packet arrived');
parser.onMetadataReceived = () => console.log('meta packet received');
parser.onScanComplete = () => console.log('scan complete');
parser.onParseError = () => console.log('parser error');

// Send data through current connection
// function sendData(data: string | Buffer): boolean {
//   if (
//     !currentConnection ||
//     currentConnection.descriptor.status !== 'connected'
//   ) {
//     console.error('No active connection');
//     return false;
//   }

//   try {
//     if (currentConnection.streams.network) {
//       currentConnection.streams.network.write(data);
//       return true;
//     } else if (currentConnection.streams.serial) {
//       currentConnection.streams.serial.write(data);
//       return true;
//     }
//   } catch (error) {
//     console.error('Failed to send data:', error);
//     return false;
//   }

//   return false;
// }

// Handle incoming data (unified for both connection types)
function handleIncomingData(data: Buffer) {
  // Process the data regardless of source
  console.log('Processing data:', data.toString());

  // Send to main window if needed
  mainWindow?.webContents.send('device-data', data.toString());
}

// Disconnect current device
// function disconnectCurrentDevice(): void {
//   if (!currentConnection) return;

//   try {
//     if (currentConnection.streams.network) {
//       currentConnection.streams.network.destroy();
//     } else if (currentConnection.streams.serial) {
//       currentConnection.streams.serial.close();
//     }
//   } catch (error) {
//     console.error('Error during disconnect:', error);
//   }

//   currentConnection = null;
// }

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).

/**
 * @ignore
 */
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

let mainWindow: BrowserWindow | null = null;
let currentDevice: RongbukDevice | null = null;

let connectedSerialDevice = null;
let connectedNetworkDevice = null;

const handleSelectDevice: SelectDeviceCallback = (error, device) => {
  if (error) {
    console.log(error);
    return;
  }

  if (device === null) return;

  if (typeof device.location == 'string') {
    // com port
    const port = new SerialPort({
      path: device.location,
      baudRate: 115200,
    });
    port.on('open', () => {});
    port.on('data', data => {});
    port.on('close', () => {});
    port.on('error', err => {}); // there is .isOpen to differentiate
  } else {
    currentDevice = device;
    currentDevice.connectionState = 'DISCONNECTED';

    let received: number = 0;
    let timer: NodeJS.Timeout | null = null;

    const client = net.createConnection(7332, device.location[0]);

    client.on('connect', () => {
      console.log(`connected to ${device.location[0]}`);
      currentDevice.connectionState = 'CONNECTED';
      parser.reset();
      // TODO: register disconnect function
    });

    client.on('data', data => {
      parser.processData(new Uint8Array(data));
      received += data.length;

      if (timer !== null) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => {
        console.log(`received ${received} bytes`);
        timer = null;
      }, 5000);
    });

    client.on('close', () => {
      console.log('tcp connection closed');
      currentDevice.connectionState = 'DISCONNECTED';
    });

    client.on('error', err => {
      console.log('tcp connection error', err);
      if (currentDevice.connectionState === 'CONNECTED') {
        client.destroy(); // close will follow soon.
      } else {
        dialog.showErrorBox(
          'Error',
          `Failed to establish a connection to ${device.name} at ${device.location}`
        );
      }
    });
  }
};

const MENUID_SELECTDEVICE = 'SelectDevice';

const updateMenuSelectDevice = (enabled: boolean): void => {
  const menu = Menu.getApplicationMenu();
  if (menu) {
    const item = menu.getMenuItemById(MENUID_SELECTDEVICE);
    if (item) {
      item.enabled = enabled;
    }
  }
};

/**
 * create main window, with extra menucommand
 */
const createMainWindow = (): void => {
  const insertMenuCommand = (): void => {
    const currentMenu = Menu.getApplicationMenu();
    if (currentMenu) {
      const fileMenu = currentMenu.items.find(item => item.label === 'File');

      if (fileMenu) {
        fileMenu.submenu?.insert(0, new MenuItem({ type: 'separator' }));
        fileMenu.submenu?.insert(
          0,
          new MenuItem({
            id: MENUID_SELECTDEVICE,
            label: 'Select Device',
            enabled: true,
            click: () =>
              mainWindow !== null &&
              SelectDevice(mainWindow, handleSelectDevice),
          })
        );

        Menu.setApplicationMenu(currentMenu);
      }
    }
  };

  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  insertMenuCommand();
  // mainWindow.webContents.openDevTools();

  // don't delete the following settings, though not used now.
  // Handle Web Serial API
  mainWindow.webContents.session.on(
    'select-serial-port',
    (event, portList, webContents, callback) => {
      console.log('Available ports:', portList);

      if (portList && portList.length > 0) {
        callback(portList[0].portId);
      } else {
        callback('');
      }
    }
  );

  mainWindow.webContents.session.setPermissionCheckHandler(
    (webContents, permission, requestingOrigin, details) => {
      return permission === 'serial';
    }
  );

  mainWindow.webContents.session.setDevicePermissionHandler(details => {
    return details.deviceType === 'serial';
  });
};

/**
 * The following two functions are dealing with
 * the difference among platforms. On Linux and Windows, 'ready' is used,
 * while on macOS, 'activate' is used.
 */
app.on('ready', createMainWindow);
app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createMainWindow();
  }
});

/**
 * exit
 */
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});
